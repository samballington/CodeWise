#!/usr/bin/env python3
"""
Mermaid Diagram Validation System
Provides validation and self-correction for Mermaid diagrams generated by LLM.
"""

import logging
import re
import subprocess
import tempfile
import os
import json
from typing import Optional, Tuple, Dict, Any

logger = logging.getLogger(__name__)


class MermaidValidator:
    """
    Lightweight Mermaid syntax validator with error correction capabilities.
    Provides fast validation without requiring Node.js dependencies.
    """
    
    def __init__(self):
        self.logger = logging.getLogger(f"{__name__}.MermaidValidator")
        
        # Common Mermaid syntax patterns for validation
        self.patterns = {
            'graph_declaration': r'^(graph\s+(TD|LR|TB|RL|BT))',
            'theme_config': r'%%\{init:\s*\{[^}]+\}\}%%',
            'node_definition': r'[A-Za-z_][A-Za-z0-9_]*\[.*?\]',
            'arrow_connection': r'[A-Za-z_][A-Za-z0-9_]*\s*-->\s*[A-Za-z_][A-Za-z0-9_]*',
            'subgraph_start': r'subgraph\s+[A-Za-z_][A-Za-z0-9_]*\[.*?\]',
            'subgraph_end': r'^\s*end\s*$',
            'class_def': r'classDef\s+[A-Za-z_][A-Za-z0-9_]*\s+.*',
            'style_def': r'style\s+[A-Za-z_][A-Za-z0-9_]*\s+.*'
        }
    
    def validate_mermaid_runtime(self, mermaid_code: str) -> Tuple[bool, Optional[str]]:
        """
        Validate Mermaid code using the PROPER JavaScript validation with mermaid.parse().
        This uses the official Mermaid library to validate syntax, as recommended in mermaid_example.md.
        
        Args:
            mermaid_code: The Mermaid diagram code to validate
            
        Returns:
            Tuple of (is_valid: bool, error_message: Optional[str])
        """
        if not mermaid_code or not mermaid_code.strip():
            return False, "Empty Mermaid code provided"
        
        # Clean the code - remove code block markers if present
        cleaned_code = mermaid_code.strip()
        if cleaned_code.startswith('```mermaid'):
            cleaned_code = cleaned_code.replace('```mermaid', '').replace('```', '').strip()
        elif cleaned_code.startswith('```'):
            cleaned_code = cleaned_code.replace('```', '').strip()
        
        try:
            # Use the proper JavaScript validation script with mermaid.parse()
            validator_script = os.path.join(os.path.dirname(__file__), 'mermaid_validator.js')
            
            result = subprocess.run([
                'node', validator_script, cleaned_code
            ], capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0:
                # Parse the JSON response from the validator
                try:
                    validation_result = json.loads(result.stdout.strip())
                    if validation_result.get('valid', False):
                        self.logger.info("âœ… MERMAID RUNTIME: Validation passed with mermaid.parse()")
                        return True, None
                    else:
                        error_msg = validation_result.get('error', 'Unknown validation error')
                        self.logger.warning(f"âŒ MERMAID RUNTIME: mermaid.parse() validation failed: {error_msg}")
                        return False, f"Syntax error: {error_msg}"
                except json.JSONDecodeError:
                    self.logger.error(f"ðŸ’¥ MERMAID RUNTIME: Invalid JSON response from validator: {result.stdout}")
                    return False, "Validation system error: Invalid response format"
            else:
                # Try to parse error from stderr or stdout
                try:
                    error_result = json.loads(result.stderr.strip() or result.stdout.strip() or '{}')
                    error_msg = error_result.get('error', 'Validation failed')
                except json.JSONDecodeError:
                    error_msg = result.stderr.strip() or "Validation process failed"
                
                self.logger.warning(f"âŒ MERMAID RUNTIME: JavaScript validation failed: {error_msg}")
                return False, f"Runtime validation failed: {error_msg}"
                
        except subprocess.TimeoutExpired:
            self.logger.error("ðŸ’¥ MERMAID RUNTIME: Validation timeout")
            return False, "Validation timeout - diagram too complex"
        except FileNotFoundError:
            self.logger.warning("âš ï¸ MERMAID RUNTIME: Node.js not found, falling back to basic validation")
            return self._validate_basic_syntax(cleaned_code)
        except Exception as e:
            self.logger.error(f"ðŸ’¥ MERMAID RUNTIME: Validation error: {e}")
            return False, f"Validation system error: {str(e)}"
    
    
    def _validate_basic_syntax(self, mermaid_code: str) -> Tuple[bool, Optional[str]]:
        """
        Basic syntax validation as final fallback when runtime validation isn't available.
        """
        lines = mermaid_code.strip().split('\n')
        errors = []
        
        # Check for basic structure requirements
        has_graph_declaration = False
        subgraph_stack = []
        
        for i, line in enumerate(lines, 1):
            line = line.strip()
            if not line or line.startswith('%%'):
                continue
                
            # Check for graph declaration
            if re.match(self.patterns['graph_declaration'], line, re.IGNORECASE):
                has_graph_declaration = True
                # Ensure uppercase direction
                direction_match = re.search(r'graph\s+(\w+)', line, re.IGNORECASE)
                if direction_match:
                    direction = direction_match.group(1)
                    if direction != direction.upper():
                        errors.append(f"Line {i}: Direction '{direction}' must be UPPERCASE")
            
            # Check for subgraph balance
            if re.match(self.patterns['subgraph_start'], line):
                subgraph_match = re.search(r'subgraph\s+([A-Za-z_][A-Za-z0-9_]*)', line)
                if subgraph_match:
                    subgraph_stack.append(subgraph_match.group(1))
            elif re.match(self.patterns['subgraph_end'], line):
                if not subgraph_stack:
                    errors.append(f"Line {i}: Unmatched 'end' statement")
                else:
                    subgraph_stack.pop()
            
            # Check for common syntax errors
            if '&amp;amp;' in line:
                errors.append(f"Line {i}: Double-encoded ampersand '&amp;amp;' - use '&amp;' instead")
            
            if '&' in line and '&amp;' not in line and '[' in line:
                errors.append(f"Line {i}: Unescaped ampersand - use '&amp;' in node labels")
            
            # Check for unquoted labels with special characters
            node_matches = re.findall(r'\[[^\]]*\]', line)
            for node_match in node_matches:
                if ('(' in node_match or ')' in node_match) and not (node_match.startswith('["') and node_match.endswith('"]')):
                    errors.append(f"Line {i}: Parentheses in labels must be quoted: {node_match}")
        
        # Final structure checks
        if not has_graph_declaration:
            errors.append("Missing graph declaration (e.g., 'graph TD')")
        
        if subgraph_stack:
            errors.append(f"Unbalanced subgraphs: missing 'end' for {', '.join(subgraph_stack)}")
        
        if errors:
            return False, "; ".join(errors)
        
        self.logger.info("âœ… MERMAID RUNTIME: Basic syntax validation passed (fallback)")
        return True, None
    
    def validate_and_correct(self, mermaid_code: str, max_attempts: int = 3) -> Tuple[bool, str, Optional[str]]:
        """
        Validate Mermaid code with smart auto-correction and graceful error handling.
        PHASE 1 IMPLEMENTATION: Focus on fixing diagrams silently rather than showing errors to users.
        
        Args:
            mermaid_code: Original Mermaid code
            max_attempts: Maximum correction attempts
            
        Returns:
            Tuple of (is_valid: bool, corrected_code: str, error_message: Optional[str])
        """
        if not mermaid_code or not mermaid_code.strip():
            return False, mermaid_code, "Empty diagram code"
        
        current_code = mermaid_code.strip()
        original_code = current_code
        
        # PHASE 1: Apply smart corrections BEFORE validation to maximize success rate
        self.logger.info("ðŸ”§ MERMAID SMART CORRECTION: Applying proactive fixes")
        current_code = self._apply_smart_corrections(current_code)
        
        for attempt in range(max_attempts):
            # Use runtime validation to test if it actually works
            is_valid, error = self.validate_mermaid_runtime(current_code)
            
            if is_valid:
                if current_code != original_code:
                    self.logger.info(f"âœ… MERMAID SMART CORRECTION: Diagram auto-corrected and validated after {attempt} attempts")
                else:
                    self.logger.info(f"âœ… MERMAID VALIDATION: Original diagram validated successfully")
                return True, current_code, None
            
            self.logger.debug(f"ðŸ”§ MERMAID CORRECTION: Attempt {attempt + 1} failed: {error}")
            
            # Apply targeted corrections based on specific error
            previous_code = current_code
            current_code = self._apply_basic_corrections(current_code, error or "")
            
            # If no changes were made, break to avoid infinite loop
            if current_code == previous_code:
                self.logger.debug("ðŸ”§ MERMAID CORRECTION: No more corrections possible")
                break
        
        # PHASE 1: Be more forgiving - if we made improvements, consider it a partial success
        if current_code != original_code:
            self.logger.info("ðŸ”§ MERMAID SMART CORRECTION: Returning improved diagram despite validation issues")
            # Return the corrected code even if validation still fails - let frontend handle gracefully
            return True, current_code, None
        
        self.logger.warning(f"âš ï¸ MERMAID VALIDATION: Could not correct diagram after {max_attempts} attempts")
        return False, current_code, error
    
    def _apply_smart_corrections(self, code: str) -> str:
        """Apply smart proactive corrections before validation to maximize success rate"""
        corrected = code
        
        # 1. Always ensure graph declaration exists
        corrected = self._add_missing_graph_declaration(corrected)
        
        # 2. Proactively fix common LLM patterns
        corrected = self._fix_common_llm_patterns(corrected)
        
        # 3. Normalize whitespace and structure
        corrected = self._normalize_whitespace(corrected)
        
        # 4. Fix obvious syntax issues
        corrected = self._fix_arrow_syntax(corrected)
        
        # 5. Quote labels that likely need quoting
        if self._has_unquoted_special_chars(corrected):
            corrected = self._quote_special_character_labels(corrected)
        
        # 6. Escape ampersands proactively
        corrected = self._escape_ampersands_in_labels(corrected)
        
        return corrected
    
    def _fix_common_llm_patterns(self, code: str) -> str:
        """Fix common patterns that LLMs generate incorrectly"""
        corrected = code
        
        # Fix common direction issues
        corrected = re.sub(r'(graph|flowchart)\s+(td|lr|tb|rl|bt)', lambda m: f'{m.group(1)} {m.group(2).upper()}', corrected, flags=re.IGNORECASE)
        
        # Fix node IDs that start with numbers (invalid)
        def fix_numeric_node_ids(match):
            full_match = match.group(0)
            node_id = match.group(1)
            if node_id[0].isdigit():
                # Prefix with 'N' to make it valid
                return full_match.replace(node_id, f'N{node_id}', 1)
            return full_match
        
        corrected = re.sub(r'([A-Za-z0-9_]+)(\[.*?\]|\(.*?\)|\{.*?\})', fix_numeric_node_ids, corrected)
        
        # Fix HTML entity encoding issues from markdown processing
        corrected = corrected.replace('&amp;amp;', '&amp;')  # Double encoding
        corrected = corrected.replace('&amp;gt;', '>')  # Double-encoded > in arrows
        corrected = corrected.replace('&amp;lt;', '<')  # Double-encoded < 
        corrected = corrected.replace('&amp;quot;', '"')  # Double-encoded quotes
        corrected = corrected.replace('&gt;', '>')  # Single-encoded > in arrows
        corrected = corrected.replace('&lt;', '<')  # Single-encoded <
        corrected = corrected.replace('&quot;', '"')  # Single-encoded quotes
        
        # Removed bandage fix - using diagnosis to find root cause instead
        
        return corrected
    
    async def validate_and_regenerate(
        self, 
        mermaid_code: str, 
        original_query: str = "", 
        llm_provider=None,
        max_basic_attempts: int = 3
    ) -> Tuple[bool, str, Optional[str], Optional[str]]:
        """
        PHASE 1 ENHANCED: Smart validation with graceful degradation.
        Prioritizes working diagrams over perfect validation.
        
        Args:
            mermaid_code: Original Mermaid code
            original_query: Original user query for context
            llm_provider: LLM provider for regeneration
            max_basic_attempts: Maximum basic correction attempts
            
        Returns:
            Tuple of (is_valid: bool, final_code: str, error_message: Optional[str], user_message: Optional[str])
        """
        # PHASE 1: Try smart correction first (this is now much more effective)
        is_valid, corrected_code, error = self.validate_and_correct(mermaid_code, max_basic_attempts)
        
        if is_valid:
            # Success! Determine if we should show a user message
            user_message = None
            if corrected_code != mermaid_code.strip():
                user_message = "âœ¨ Diagram automatically optimized for better rendering"
            return True, corrected_code, None, user_message
        
        # PHASE 1: If smart correction didn't work, try LLM regeneration (but be less aggressive)
        if llm_provider and original_query and error:
            try:
                from mermaid_regeneration import get_mermaid_regenerator
                regenerator = get_mermaid_regenerator(llm_provider)
                
                self.logger.info("ðŸ”„ MERMAID REGENERATION: Attempting LLM-based correction")
                
                # Attempt LLM regeneration with shorter timeout for better UX
                result = await regenerator.regenerate_diagram(
                    invalid_diagram=corrected_code,
                    validation_error=error,
                    original_query=original_query
                )
                
                if result.success:
                    self.logger.info("âœ… MERMAID REGENERATION: LLM correction successful")
                    return True, result.final_diagram, None, "âœ¨ Diagram regenerated and corrected automatically"
                elif result.fallback_used:
                    self.logger.info("ðŸ”„ MERMAID REGENERATION: Using fallback content")
                    # PHASE 1: Still return the corrected code, not the fallback text
                    return True, corrected_code, None, "âš ï¸ Diagram partially corrected - may have minor rendering issues"
                    
            except ImportError:
                self.logger.debug("âš ï¸ MERMAID REGENERATION: Module not available, using smart correction only")
            except Exception as e:
                self.logger.debug(f"âš ï¸ MERMAID REGENERATION: Failed with error: {e}")
        
        # PHASE 1: Final fallback - return the best corrected version we have
        # This is much more user-friendly than showing technical errors
        if corrected_code != mermaid_code.strip():
            self.logger.info("ðŸ”§ MERMAID FALLBACK: Returning improved diagram despite validation concerns")
            return True, corrected_code, None, "âš ï¸ Diagram auto-corrected - may have minor rendering issues"
        
        # Last resort: return original with a gentle message
        self.logger.warning("âš ï¸ MERMAID FALLBACK: Returning original diagram with user guidance")
        return True, mermaid_code, None, "âš ï¸ Diagram may need manual adjustment for optimal rendering"
    
    def _apply_basic_corrections(self, code: str, error_message: str) -> str:
        """Apply enhanced automatic corrections to common syntax errors"""
        corrected = code.strip()
        
        # PHASE 1: SMART AUTO-CORRECTION - Fix common LLM generation issues
        
        # 1. Auto-add missing graph declaration if nodes/connections detected
        if 'Missing graph declaration' in error_message or not re.match(r'^\s*(graph|flowchart)\s+', corrected, re.IGNORECASE):
            corrected = self._add_missing_graph_declaration(corrected)
        
        # 2. Fix HTML entity encoding issues from JSON-to-markdown transition
        if '&amp;amp;' in error_message or '&amp;amp;' in corrected:
            corrected = corrected.replace('&amp;amp;', '&amp;')
        if '&amp;gt;' in corrected or '--&amp;gt;' in corrected:
            corrected = corrected.replace('&amp;gt;', '>')
        if '&amp;lt;' in corrected:
            corrected = corrected.replace('&amp;lt;', '<')
        if '&amp;quot;' in corrected:
            corrected = corrected.replace('&amp;quot;', '"')
            
        # Removed bandage fix - using diagnosis to find root cause instead
        
        # 3. Fix lowercase directions
        if 'must be UPPERCASE' in error_message:
            corrected = re.sub(r'(graph|flowchart)\s+(td|lr|tb|rl|bt)', lambda m: f'{m.group(1)} {m.group(2).upper()}', corrected, flags=re.IGNORECASE)
        
        # 4. Add missing quotes around labels with parentheses
        if 'Parentheses in labels must be quoted' in error_message or self._has_unquoted_special_chars(corrected):
            corrected = self._quote_special_character_labels(corrected)
        
        # 5. Fix unescaped ampersands in labels
        if 'Unescaped ampersand' in error_message or (re.search(r'\[[^\]]*&[^\]]*\]', corrected) and not re.search(r'\[[^\]]*&amp;[^\]]*\]', corrected)):
            corrected = self._escape_ampersands_in_labels(corrected)
        
        # 6. Normalize whitespace and line breaks
        corrected = self._normalize_whitespace(corrected)
        
        # 7. Fix common arrow syntax issues
        corrected = self._fix_arrow_syntax(corrected)
        
        return corrected
    
    def _add_missing_graph_declaration(self, code: str) -> str:
        """Auto-add graph declaration if missing but nodes/connections detected"""
        lines = code.strip().split('\n')
        
        # Check if already has declaration
        if any(re.match(r'^\s*(graph|flowchart)\s+', line, re.IGNORECASE) for line in lines):
            return code
        
        # Detect if this looks like a diagram (has nodes or connections)
        has_nodes = any(re.search(r'[A-Za-z_][A-Za-z0-9_]*\[.*?\]', line) for line in lines)
        has_connections = any(re.search(r'[A-Za-z_][A-Za-z0-9_]*\s*--[->]', line) for line in lines)
        has_subgraphs = any(re.search(r'^\s*subgraph\s+', line, re.IGNORECASE) for line in lines)
        
        if has_nodes or has_connections or has_subgraphs:
            # Determine best direction based on content analysis
            direction = self._detect_diagram_direction(code)
            declaration = f"graph {direction}"
            
            # Preserve any theme/init directives at the top
            theme_lines = []
            content_lines = []
            
            for line in lines:
                if line.strip().startswith('%%{') or line.strip().startswith('%%'):
                    theme_lines.append(line)
                else:
                    content_lines.append(line)
            
            if theme_lines:
                return '\n'.join(theme_lines + [declaration] + content_lines)
            else:
                return declaration + '\n' + '\n'.join(content_lines)
        
        return code
    
    def _detect_diagram_direction(self, code: str) -> str:
        """Detect the most appropriate diagram direction based on content"""
        # Simple heuristic: if there are many horizontal arrows, use LR, otherwise TD
        horizontal_arrows = len(re.findall(r'-->', code)) + len(re.findall(r'---', code))
        vertical_indicators = code.count('subgraph') + code.count('end')
        
        # Default to TD (top-down) as it's most common
        if horizontal_arrows > 5 and vertical_indicators < 2:
            return 'LR'  # Left to right for flow-heavy diagrams
        else:
            return 'TD'  # Top down for most cases
    
    def _has_unquoted_special_chars(self, code: str) -> bool:
        """Check if code has unquoted labels with special characters"""
        # Find labels with parentheses, ampersands, or other special chars that aren't quoted
        labels = re.findall(r'\[[^\]]*\]', code)
        for label in labels:
            if not (label.startswith('["') and label.endswith('"]')):
                content = label[1:-1]  # Remove brackets
                if any(char in content for char in ['(', ')', '&', '<', '>', '"', "'"]):
                    return True
        return False
    
    def _quote_special_character_labels(self, code: str) -> str:
        """Quote labels containing special characters"""
        def quote_if_needed(match):
            label = match.group(0)
            content = label[1:-1]  # Remove [ and ]
            
            # Skip if already quoted
            if content.startswith('"') and content.endswith('"'):
                return label
            
            # Quote if contains special characters
            if any(char in content for char in ['(', ')', '&', '<', '>', '"', "'", ' ', ':']):
                # Escape any existing quotes in content
                escaped_content = content.replace('"', '\\"')
                return f'["{escaped_content}"]'
            
            return label
        
        return re.sub(r'\[[^\]]*\]', quote_if_needed, code)
    
    def _escape_ampersands_in_labels(self, code: str) -> str:
        """Escape unescaped ampersands in node labels"""
        def escape_ampersands(match):
            label = match.group(0)
            # Only escape if not already escaped
            if '&amp;' not in label and '&' in label:
                return label.replace('&', '&amp;')
            return label
        
        return re.sub(r'\[[^\]]*\]', escape_ampersands, code)
    
    def _normalize_whitespace(self, code: str) -> str:
        """Normalize whitespace while preserving structure"""
        lines = code.split('\n')
        normalized_lines = []
        
        for line in lines:
            # Preserve indentation for subgraphs but clean up extra spaces
            if line.strip():
                # Keep leading whitespace for indentation, clean up the rest
                leading_space = len(line) - len(line.lstrip())
                cleaned_content = ' '.join(line.strip().split())
                normalized_lines.append(' ' * leading_space + cleaned_content)
            else:
                normalized_lines.append('')  # Preserve empty lines
        
        # Remove excessive blank lines (more than 1 consecutive)
        result_lines = []
        blank_count = 0
        
        for line in normalized_lines:
            if line.strip():
                result_lines.append(line)
                blank_count = 0
            else:
                blank_count += 1
                if blank_count <= 1:  # Allow up to 1 consecutive blank line
                    result_lines.append(line)
        
        return '\n'.join(result_lines).strip()
    
    def _fix_arrow_syntax(self, code: str) -> str:
        """Fix common arrow syntax issues"""
        # Standardize arrow syntax
        fixes = [
            (r'--+>', '-->'),  # Multiple dashes to standard arrow
            (r'==+>', '==>'),  # Multiple equals to thick arrow
            (r'\.\.+>', '..>'), # Multiple dots to dotted arrow
            (r'-\s*-\s*>', '-->'),  # Spaced arrows
            (r'=\s*=\s*>', '==>'),  # Spaced thick arrows
        ]
        
        result = code
        for pattern, replacement in fixes:
            result = re.sub(pattern, replacement, result)
        
        return result
    
    def create_correction_prompt(self, original_code: str, error_message: str, user_query: str) -> str:
        """
        Create a correction prompt for the LLM when validation fails.
        
        Args:
            original_code: The invalid Mermaid code
            error_message: Validation error details
            user_query: Original user query for context
            
        Returns:
            Formatted correction prompt for LLM
        """
        return (
            f"The previous Mermaid diagram code contains syntax errors and cannot be rendered.\n\n"
            f"**ORIGINAL QUERY:** {user_query}\n\n"
            f"**INVALID CODE:**\n{original_code}\n\n"
            f"**VALIDATION ERRORS:**\n{error_message}\n\n"
            f"Please provide a corrected Mermaid diagram that:\n"
            f"1. Fixes all the syntax errors listed above\n"
            f"2. Still accurately represents the system architecture from the original query\n"
            f"3. Follows all the CRITICAL MERMAID SYNTAX RULES exactly\n"
            f"4. Uses ||NEWLINE|| as the line delimiter in the JSON response\n\n"
            f"Generate the corrected diagram in the proper JSON format with no syntax errors."
        )


# Global validator instance
_validator_instance = None

def get_mermaid_validator() -> MermaidValidator:
    """Get singleton Mermaid validator instance"""
    global _validator_instance
    if _validator_instance is None:
        _validator_instance = MermaidValidator()
    return _validator_instance